---
layout: post
title:      "Sharing my old code"
date:       2019-01-24 00:51:44 +0000
permalink:  sharing_my_old_code
---


Now that I am actively seeking employment, I've been looking through my old code from college to see where I might have something good from those years to present my perspective employers.  Going through my archived code has been very interesting, not least because I'm reminded of how naive I was when I wrote that code.

## I wish that I knew what I know now

In college, I was under the impression that if I had a computer science degree, I would be qualified for a programming job once I graduated; boy was I completely mistaken about this!  Employeers want you to show  -- via a portfolio of completed, full scale projects -- that you can code, but all I had on graduation day was a B.A. and a bunch of completed homework.  These alone may have proved that I knew some programming languages, and perhaps, the essentials of theoretical computer science, but they didn't show that I could engineer fully fledged software -- *that I could code*.  And it isn't that there wasn't a career services center at my school, or that I wasn't being told to use these resources, or even that I didn't sparingly use said resources (I did), but I just didn't understand *how much I didn't know* about finding a job in software development.  So now, much older, wiser and with a proper portfolio in hand, I'm trying to find a proper place for my old code.

## They still write Java, don't they?

When I attended college, the introductory programming courses were in procedural languages (C and Pascal) and the later ones were in object oriented languages (Java and C++), and I'm finding that, at least for some of the more back-end oriented development positions, older languages like C, C++, Java and C# are useful to know.  Alas, my old code has found its place, and I've put up a bunch of samples in PDF form on [my LinkedIn profile](https://www.linkedin.com/in/efrain-perez-jr/).

First, I found an assignment for my Systems Organization II class written in C where we had to augment a "toy operating system", provided by our professor, with each successive assignment.  I chose to highlight the second assignment because on that one we added a "round robin" process scheduler and semaphoring, which was fairly complex for me to code, especially at the time.  Next, I found my final project for Systems Organization I -- a game written entirely in Assembly language!  Now I don't expect to find a job where Assembly will be useful, but being able to show that I wrote an entire (albeit small) game in it might be impressive to an employer -- like exhibiting an ERECTOR set you made, except that you smelted all the metal!<sup>1</sup>  Finally, I found an applet I made in Java for a 3-D Computer Graphics class.  It was of an animated, wireframe "Pinocchio" character that I had to render from scratch.  You can see that below:

<applet>

</applet>

## Lost and Found

I'm glad I've found some use for this old code.  When I entered Flatiron, I knew I'd be learning things I didn't in college, that I was updating my skills.  I thought there would be no use for that old work, but I'm glad to display it for all to see. 

<sup>1</sup>Assembly is taught in computer science curricula because there is little abstraction between your code and the internal workings of the CPU.  You can actually reference individual CPU registers (the carry flag!) and call system hardware interrupts (a low level communication signal between the CPU and other connected hardware, e.g. the monitor or keyboard) by their hexadecimal values!  So you learn A LOT about what's going on underneath the hood of your computer.

